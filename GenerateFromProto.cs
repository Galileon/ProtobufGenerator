using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Knacka.Se.ProtobufGenerator
{
    public class GenerateFromProto : ICanGenerateFromProto
    {
        private readonly string _protocPath;
        private readonly string _grpcPath;

        public GenerateFromProto(string protocPath, string grpcPath)
        {
            _protocPath = protocPath;
            _grpcPath = grpcPath;
        }

        public byte[] GenerateCsharpFromProto(string protoPath)
        {
            if (string.IsNullOrEmpty(_protocPath))
                return null;

            string infile = Path.GetFileName(protoPath);
            string indir = Path.GetDirectoryName(protoPath); // without last '\'
            string outdir = GetTempDir();

            var args = $"--csharp_out={outdir} --proto_path={indir} {infile}";
            if (!string.IsNullOrEmpty(_grpcPath))
            {
                args = string.Concat(args, " --plugin=protoc-gen-grpc=", _grpcPath, " --grpc_out=", outdir);
            }

            var exitCode = RunProtoc(_protocPath, args, indir, out string stdout, out string stderr);

            Debug.WriteIf(stdout.Length > 0, stdout);
            Debug.WriteIf(stderr.Length > 0, stderr);

            if (!string.IsNullOrEmpty(stderr))
            {
                throw new InvalidOperationException(stderr);
            }

            var files = Directory.GetFiles(outdir);
            if (files?.Any() == true)
            {
                using (var ms = new MemoryStream())
                using (var sw = new StreamWriter(ms))
                {
                    sw.WriteLine($"// Generated by ProtobufGenerator {DateTime.Now:yyy-MM-dd HH:mm:ss}");
                    sw.WriteLine("\r\n#region Using statments\r\n");
                    foreach (var pass in Enumerable.Range(0, 2))
                    {
                        foreach (var file in files)
                        {
                            using (var fs = File.OpenRead(Path.Combine(outdir, file)))
                            using (var sr = new StreamReader(fs))
                            {
                                if (pass == 1) sw.WriteLine($"\r\n#region File \"{Path.GetFileName(file)}\"\r\n");
                                string line;
                                var re = new Regex(@"^\s*using");
                                while ((line = sr.ReadLine()) != null)
                                {
                                    if (re.IsMatch(line) ^ pass == 1)
                                    {
                                        sw.WriteLine(line);
                                    }
                                }
                                if (pass == 1) sw.WriteLine("\r\n#endregion");
                            }
                        }
                        if(pass == 0) sw.WriteLine("\r\n#endregion");
                        sw.Flush();
                    }
                    CleanTempDir(outdir);
                    return ms.ToArray();
                }
            }
            CleanTempDir(outdir);
            return null;
        }

        private static void CleanTempDir(string outdir)
        {
            try
            {
                Directory.Delete(outdir, true);
            }
            catch (Exception)
            {
            }
        }

        private static string GetTempDir()
        {
            var tmpPath = Path.GetTempPath();
            var tries = 100;
            var r = new Random();
            while (tries-- > 0)
            {
                var path = Path.Combine(tmpPath, $"protoc-{r.Next():x}");
                if (!Directory.Exists(path))
                {
                    try
                    {
                        Directory.CreateDirectory(path);
                        return path;
                    }
                    catch (Exception x)
                    {
                        Debug.WriteLine($"{x.GetType().Name}: {x.Message}, attempting to create path \"{path}\"", "Exceptions");
                        break;
                    }
                }
            }
            return null;
        }

        static int RunProtoc(string path, string arguments, string workingDir, out string stdout, out string stderr)
        {
            using (var proc = new Process())
            {
                var psi = proc.StartInfo;
                psi.FileName = path;
                psi.Arguments = arguments;
                if (!string.IsNullOrEmpty(workingDir)) psi.WorkingDirectory = workingDir;
                psi.RedirectStandardError = psi.RedirectStandardOutput = true;
                psi.UseShellExecute = false;
                psi.CreateNoWindow = true;
                proc.Start();
                var stdoutTask = proc.StandardOutput.ReadToEndAsync();
                var stderrTask = proc.StandardError.ReadToEndAsync();
                if (!proc.WaitForExit(5000))
                {
                    try { proc.Kill(); } catch { }
                }
                var exitCode = proc.ExitCode;
                stderr = stdout = "";
                if (stdoutTask.Wait(1000)) stdout = stdoutTask.Result;
                if (stderrTask.Wait(1000)) stderr = stderrTask.Result;

                return exitCode;
            }
        }
    }
}

